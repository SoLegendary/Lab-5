<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lab3_project: main module documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lab3_project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">main module documentation</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_f_c_c_o_b.html">TFCCOB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafd55a272ed701c0ea1caa8922fd4ded0"><td class="memItemLeft" align="right" valign="top"><a id="gafd55a272ed701c0ea1caa8922fd4ded0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CMD_STARTUP</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gafd55a272ed701c0ea1caa8922fd4ded0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad64394fffb2b4f7b396494845b7a3508"><td class="memItemLeft" align="right" valign="top"><a id="gad64394fffb2b4f7b396494845b7a3508"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CMD_VERSION</b>&#160;&#160;&#160;0x09</td></tr>
<tr class="separator:gad64394fffb2b4f7b396494845b7a3508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6ad766e0645b5b40eb5480a93ea583"><td class="memItemLeft" align="right" valign="top"><a id="gadf6ad766e0645b5b40eb5480a93ea583"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CMD_NUMBER</b>&#160;&#160;&#160;0x0B</td></tr>
<tr class="separator:gadf6ad766e0645b5b40eb5480a93ea583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4efbe07fba04914334f45f97ac0af54"><td class="memItemLeft" align="right" valign="top"><a id="gab4efbe07fba04914334f45f97ac0af54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CMD_TOWERMODE</b>&#160;&#160;&#160;0x0D</td></tr>
<tr class="separator:gab4efbe07fba04914334f45f97ac0af54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d88c2acf5d0158f4c75cceaca1bfde"><td class="memItemLeft" align="right" valign="top"><a id="ga64d88c2acf5d0158f4c75cceaca1bfde"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CMD_PROGBYTE</b>&#160;&#160;&#160;0x07</td></tr>
<tr class="separator:ga64d88c2acf5d0158f4c75cceaca1bfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439105059cfaa05782eaf0a771e852ce"><td class="memItemLeft" align="right" valign="top"><a id="ga439105059cfaa05782eaf0a771e852ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CMD_READBYTE</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga439105059cfaa05782eaf0a771e852ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47228d2cc78c94dbd415570de4f9bc7b"><td class="memItemLeft" align="right" valign="top"><a id="ga47228d2cc78c94dbd415570de4f9bc7b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CMD_SETTIME</b>&#160;&#160;&#160;0x0C</td></tr>
<tr class="separator:ga47228d2cc78c94dbd415570de4f9bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad9207f49ab9ed061b6dca6063112ca60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gad9207f49ab9ed061b6dca6063112ca60">FIFO_Init</a> (<a class="el" href="struct_t_f_i_f_o.html">TFIFO</a> *const FIFO)</td></tr>
<tr class="memdesc:gad9207f49ab9ed061b6dca6063112ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the FIFO before first use.  <a href="#gad9207f49ab9ed061b6dca6063112ca60">More...</a><br /></td></tr>
<tr class="separator:gad9207f49ab9ed061b6dca6063112ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace64ba4e6bd943f990a294693156cc3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gace64ba4e6bd943f990a294693156cc3b">FIFO_Put</a> (<a class="el" href="struct_t_f_i_f_o.html">TFIFO</a> *const FIFO, const uint8_t data)</td></tr>
<tr class="memdesc:gace64ba4e6bd943f990a294693156cc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put one character into the FIFO.  <a href="#gace64ba4e6bd943f990a294693156cc3b">More...</a><br /></td></tr>
<tr class="separator:gace64ba4e6bd943f990a294693156cc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6407e3daf24a826a7f17d3e48865e89a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga6407e3daf24a826a7f17d3e48865e89a">FIFO_Get</a> (<a class="el" href="struct_t_f_i_f_o.html">TFIFO</a> *const FIFO, uint8_t *const dataPtr)</td></tr>
<tr class="memdesc:ga6407e3daf24a826a7f17d3e48865e89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one character from the FIFO.  <a href="#ga6407e3daf24a826a7f17d3e48865e89a">More...</a><br /></td></tr>
<tr class="separator:ga6407e3daf24a826a7f17d3e48865e89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5782279b5e558cafc2f135c0a1177d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gaa5782279b5e558cafc2f135c0a1177d3">Flash_Init</a> (void)</td></tr>
<tr class="memdesc:gaa5782279b5e558cafc2f135c0a1177d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Flash module.  <a href="#gaa5782279b5e558cafc2f135c0a1177d3">More...</a><br /></td></tr>
<tr class="separator:gaa5782279b5e558cafc2f135c0a1177d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50871aff0f5af1e092aea3ed2545cf72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga50871aff0f5af1e092aea3ed2545cf72">Flash_AllocateVar</a> (volatile void **variable, const uint8_t size)</td></tr>
<tr class="memdesc:ga50871aff0f5af1e092aea3ed2545cf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates space for a non-volatile variable in the Flash memory.  <a href="#ga50871aff0f5af1e092aea3ed2545cf72">More...</a><br /></td></tr>
<tr class="separator:ga50871aff0f5af1e092aea3ed2545cf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da7dcc0c6ef765546c79bbe25b48479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga5da7dcc0c6ef765546c79bbe25b48479">Flash_Write32</a> (volatile uint32_t *const address, const uint32_t data)</td></tr>
<tr class="memdesc:ga5da7dcc0c6ef765546c79bbe25b48479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 32-bit number to Flash.  <a href="#ga5da7dcc0c6ef765546c79bbe25b48479">More...</a><br /></td></tr>
<tr class="separator:ga5da7dcc0c6ef765546c79bbe25b48479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1458f5e4ac15e1848ae0bde32fe5b5f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga1458f5e4ac15e1848ae0bde32fe5b5f3">Flash_Write16</a> (volatile uint16_t *const address, const uint16_t data)</td></tr>
<tr class="memdesc:ga1458f5e4ac15e1848ae0bde32fe5b5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 16-bit number to Flash.  <a href="#ga1458f5e4ac15e1848ae0bde32fe5b5f3">More...</a><br /></td></tr>
<tr class="separator:ga1458f5e4ac15e1848ae0bde32fe5b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6f34b272d8ed7b0f897b43e65f2cc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga1e6f34b272d8ed7b0f897b43e65f2cc0">Flash_Write8</a> (volatile uint8_t *const address, const uint8_t data)</td></tr>
<tr class="memdesc:ga1e6f34b272d8ed7b0f897b43e65f2cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an 8-bit number to Flash.  <a href="#ga1e6f34b272d8ed7b0f897b43e65f2cc0">More...</a><br /></td></tr>
<tr class="separator:ga1e6f34b272d8ed7b0f897b43e65f2cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06868787ccef73e69bd236d3b93b68f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga06868787ccef73e69bd236d3b93b68f3">Flash_Erase</a> (void)</td></tr>
<tr class="memdesc:ga06868787ccef73e69bd236d3b93b68f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the entire Flash sector.  <a href="#ga06868787ccef73e69bd236d3b93b68f3">More...</a><br /></td></tr>
<tr class="separator:ga06868787ccef73e69bd236d3b93b68f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8e07494e5be81d37cc695feb380e68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga6a8e07494e5be81d37cc695feb380e68">FTM_Init</a> (void)</td></tr>
<tr class="memdesc:ga6a8e07494e5be81d37cc695feb380e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the FTM before first use.  <a href="#ga6a8e07494e5be81d37cc695feb380e68">More...</a><br /></td></tr>
<tr class="separator:ga6a8e07494e5be81d37cc695feb380e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4928af832114c8173e43d10e4144c1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gae4928af832114c8173e43d10e4144c1f">FTM_Set</a> (const <a class="el" href="struct_t_f_t_m_channel.html">TFTMChannel</a> *const aFTMChannel)</td></tr>
<tr class="memdesc:gae4928af832114c8173e43d10e4144c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a timer channel.  <a href="#gae4928af832114c8173e43d10e4144c1f">More...</a><br /></td></tr>
<tr class="separator:gae4928af832114c8173e43d10e4144c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb34a0dd79d879502fd81c0efa9440ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gabb34a0dd79d879502fd81c0efa9440ec">FTM_StartTimer</a> (const <a class="el" href="struct_t_f_t_m_channel.html">TFTMChannel</a> *const aFTMChannel)</td></tr>
<tr class="memdesc:gabb34a0dd79d879502fd81c0efa9440ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a timer if set up for output compare.  <a href="#gabb34a0dd79d879502fd81c0efa9440ec">More...</a><br /></td></tr>
<tr class="separator:gabb34a0dd79d879502fd81c0efa9440ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445500277ba0e363873b34cffc015745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga445500277ba0e363873b34cffc015745">__attribute__</a> ((interrupt))</td></tr>
<tr class="memdesc:ga445500277ba0e363873b34cffc015745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt service routine for the FTM.  <a href="#ga445500277ba0e363873b34cffc015745">More...</a><br /></td></tr>
<tr class="separator:ga445500277ba0e363873b34cffc015745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5d2a9d1aacacc05e4d772a555b2d9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gaea5d2a9d1aacacc05e4d772a555b2d9d">LEDs_Init</a> (void)</td></tr>
<tr class="memdesc:gaea5d2a9d1aacacc05e4d772a555b2d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the LEDs before first use.  <a href="#gaea5d2a9d1aacacc05e4d772a555b2d9d">More...</a><br /></td></tr>
<tr class="separator:gaea5d2a9d1aacacc05e4d772a555b2d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5974ccd48f4e74eb3be78a51ebf16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga1e5974ccd48f4e74eb3be78a51ebf16f">LEDs_On</a> (const <a class="el" href="_l_e_ds_8h.html#a833ecccaa4c55e8365e84d6c02f92ec1">TLED</a> color)</td></tr>
<tr class="memdesc:ga1e5974ccd48f4e74eb3be78a51ebf16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns an LED on.  <a href="#ga1e5974ccd48f4e74eb3be78a51ebf16f">More...</a><br /></td></tr>
<tr class="separator:ga1e5974ccd48f4e74eb3be78a51ebf16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefecb26a8d3457bc7f7a7b2fb8b7311f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gaefecb26a8d3457bc7f7a7b2fb8b7311f">LEDs_Off</a> (const <a class="el" href="_l_e_ds_8h.html#a833ecccaa4c55e8365e84d6c02f92ec1">TLED</a> color)</td></tr>
<tr class="memdesc:gaefecb26a8d3457bc7f7a7b2fb8b7311f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off an LED.  <a href="#gaefecb26a8d3457bc7f7a7b2fb8b7311f">More...</a><br /></td></tr>
<tr class="separator:gaefecb26a8d3457bc7f7a7b2fb8b7311f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b9c778cd7168ea0df402b263a609bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga00b9c778cd7168ea0df402b263a609bb">LEDs_Toggle</a> (const <a class="el" href="_l_e_ds_8h.html#a833ecccaa4c55e8365e84d6c02f92ec1">TLED</a> color)</td></tr>
<tr class="memdesc:ga00b9c778cd7168ea0df402b263a609bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles an LED.  <a href="#ga00b9c778cd7168ea0df402b263a609bb">More...</a><br /></td></tr>
<tr class="separator:ga00b9c778cd7168ea0df402b263a609bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa028adfe8bbcabdb7897a1898874e141"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gaa028adfe8bbcabdb7897a1898874e141">HandleStartupPacket</a> (void)</td></tr>
<tr class="memdesc:gaa028adfe8bbcabdb7897a1898874e141"><td class="mdescLeft">&#160;</td><td class="mdescRight">The startup packet will send four packets back to the PC by default It will send the startup, version, tower number and mode packets. If flash is reset, tower number and mode will be set to studentNumber and defaultTowerMode.  <a href="#gaa028adfe8bbcabdb7897a1898874e141">More...</a><br /></td></tr>
<tr class="separator:gaa028adfe8bbcabdb7897a1898874e141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84fe5ea768aedc0d1e4e2818ff8bd406"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga84fe5ea768aedc0d1e4e2818ff8bd406">HandleVersionPacket</a> (void)</td></tr>
<tr class="memdesc:ga84fe5ea768aedc0d1e4e2818ff8bd406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the tower version packet in accordance with the Tower Serial Communication Protocol document.  <a href="#ga84fe5ea768aedc0d1e4e2818ff8bd406">More...</a><br /></td></tr>
<tr class="separator:ga84fe5ea768aedc0d1e4e2818ff8bd406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86820f24fb68dfbb9d2a3b772af94b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gac86820f24fb68dfbb9d2a3b772af94b9">HandleNumberPacket</a> (void)</td></tr>
<tr class="memdesc:gac86820f24fb68dfbb9d2a3b772af94b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the tower number packet in accordance with the Tower Serial Communication Protocol document.  <a href="#gac86820f24fb68dfbb9d2a3b772af94b9">More...</a><br /></td></tr>
<tr class="separator:gac86820f24fb68dfbb9d2a3b772af94b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae491978a09b1e90673364b69746bcae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gae491978a09b1e90673364b69746bcae1">HandleTowerModePacket</a> (void)</td></tr>
<tr class="memdesc:gae491978a09b1e90673364b69746bcae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the tower mode packet in accordance with the Tower Serial Communication Protocol document.  <a href="#gae491978a09b1e90673364b69746bcae1">More...</a><br /></td></tr>
<tr class="separator:gae491978a09b1e90673364b69746bcae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87fcb3feeebe2013c2376a2635080be5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga87fcb3feeebe2013c2376a2635080be5">HandleProgBytePacket</a> (void)</td></tr>
<tr class="memdesc:ga87fcb3feeebe2013c2376a2635080be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a Flash Program Byte packet as per the Tower Serial Communication Protocol document by writing the data in parameter3 to the address given in parameter1.  <a href="#ga87fcb3feeebe2013c2376a2635080be5">More...</a><br /></td></tr>
<tr class="separator:ga87fcb3feeebe2013c2376a2635080be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga229934574bc13961e301d7c8ea4742cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga229934574bc13961e301d7c8ea4742cc">HandleReadBytePacket</a> (void)</td></tr>
<tr class="memdesc:ga229934574bc13961e301d7c8ea4742cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a Flash Read Byte packet as per the Tower Serial Communication Protocol document by putting in a packet with the address of the flash byte read and the data contained in that address.  <a href="#ga229934574bc13961e301d7c8ea4742cc">More...</a><br /></td></tr>
<tr class="separator:ga229934574bc13961e301d7c8ea4742cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7670b320e43d8d708a92bbe0746eff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga5e7670b320e43d8d708a92bbe0746eff">HandleSetTimePacket</a> (void)</td></tr>
<tr class="memdesc:ga5e7670b320e43d8d708a92bbe0746eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a Set Time packet as per the Tower Serial Communication Protocol document by setting sending the parameters of the packet to the RTC module to be set.  <a href="#ga5e7670b320e43d8d708a92bbe0746eff">More...</a><br /></td></tr>
<tr class="separator:ga5e7670b320e43d8d708a92bbe0746eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a5cb735555819b24719d6078028181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gab7a5cb735555819b24719d6078028181">HandlePacket</a> (void)</td></tr>
<tr class="memdesc:gab7a5cb735555819b24719d6078028181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the packet by first checking to see what type of packet it is and processing it as per the Tower Serial Communication Protocol document.  <a href="#gab7a5cb735555819b24719d6078028181">More...</a><br /></td></tr>
<tr class="separator:gab7a5cb735555819b24719d6078028181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e32d3437f8fdbf06974d23242a9462"><td class="memItemLeft" align="right" valign="top"><a id="ga83e32d3437f8fdbf06974d23242a9462"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga83e32d3437f8fdbf06974d23242a9462">PITCallback</a> (void *arg)</td></tr>
<tr class="memdesc:ga83e32d3437f8fdbf06974d23242a9462"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback function for use as a PIT_Init parameter Every 500ms PIT_ISR is triggered and toggles Green LED. <br /></td></tr>
<tr class="separator:ga83e32d3437f8fdbf06974d23242a9462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dabe81b72bf8ec8155cd875975beb07"><td class="memItemLeft" align="right" valign="top"><a id="ga2dabe81b72bf8ec8155cd875975beb07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga2dabe81b72bf8ec8155cd875975beb07">RTCCallback</a> (void *arg)</td></tr>
<tr class="memdesc:ga2dabe81b72bf8ec8155cd875975beb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback function for use as an RTC_Init parameter Every 1s the RTC interrupt occurs to send back clock time to the PC and toggles Yellow LED. <br /></td></tr>
<tr class="separator:ga2dabe81b72bf8ec8155cd875975beb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1796ae9fd33efded3fd853ba9e56d71"><td class="memItemLeft" align="right" valign="top"><a id="gad1796ae9fd33efded3fd853ba9e56d71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gad1796ae9fd33efded3fd853ba9e56d71">FTM0Callback</a> (void *arg)</td></tr>
<tr class="memdesc:gad1796ae9fd33efded3fd853ba9e56d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback function for use as an FTM_Set parameter After a 1s delay set by <a class="el" href="packet_8c.html" title="Contains functions for handling packets in accordance with the Tower Communication Protocol document ...">Packet.c</a> receiving a valid packet and turning on Blue LED, this turns it off. <br /></td></tr>
<tr class="separator:gad1796ae9fd33efded3fd853ba9e56d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top"><a id="ga840291bc02cba5474a4cb46a9b9566fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>main</b> (void)</td></tr>
<tr class="separator:ga840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga414aa3f521fdfd6e4586d98a946b6ab2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga414aa3f521fdfd6e4586d98a946b6ab2">Packet_Init</a> (const uint32_t baudRate, const uint32_t moduleClk)</td></tr>
<tr class="memdesc:ga414aa3f521fdfd6e4586d98a946b6ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the packets by calling the initialization routines of the supporting software modules.  <a href="#ga414aa3f521fdfd6e4586d98a946b6ab2">More...</a><br /></td></tr>
<tr class="separator:ga414aa3f521fdfd6e4586d98a946b6ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58a17928cd5e556e1567b2fde9f88f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gac58a17928cd5e556e1567b2fde9f88f0">Packet_Get</a> (void)</td></tr>
<tr class="memdesc:gac58a17928cd5e556e1567b2fde9f88f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get a packet from the received data.  <a href="#gac58a17928cd5e556e1567b2fde9f88f0">More...</a><br /></td></tr>
<tr class="separator:gac58a17928cd5e556e1567b2fde9f88f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431a1e1da25a8214a502ec81f88fc3f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga431a1e1da25a8214a502ec81f88fc3f1">Packet_Put</a> (const uint8_t command, const uint8_t parameter1, const uint8_t parameter2, const uint8_t parameter3)</td></tr>
<tr class="memdesc:ga431a1e1da25a8214a502ec81f88fc3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a packet and places it in the transmit FIFO buffer.  <a href="#ga431a1e1da25a8214a502ec81f88fc3f1">More...</a><br /></td></tr>
<tr class="separator:ga431a1e1da25a8214a502ec81f88fc3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69097a83912a25b357df1046aea9b52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gae69097a83912a25b357df1046aea9b52">PIT_Init</a> (const uint32_t moduleClk, void(*userFunction)(void *), void *userArguments)</td></tr>
<tr class="memdesc:gae69097a83912a25b357df1046aea9b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the PIT before first use.  <a href="#gae69097a83912a25b357df1046aea9b52">More...</a><br /></td></tr>
<tr class="separator:gae69097a83912a25b357df1046aea9b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae012c6f6b7396828c558c92ad0a27ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gae012c6f6b7396828c558c92ad0a27ed5">PIT_Set</a> (const uint32_t period, const bool restart)</td></tr>
<tr class="memdesc:gae012c6f6b7396828c558c92ad0a27ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the desired period of the PIT.  <a href="#gae012c6f6b7396828c558c92ad0a27ed5">More...</a><br /></td></tr>
<tr class="separator:gae012c6f6b7396828c558c92ad0a27ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed902f6158d6681e4b05d078575e4b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gaed902f6158d6681e4b05d078575e4b09">PIT_Enable</a> (const bool enable)</td></tr>
<tr class="memdesc:gaed902f6158d6681e4b05d078575e4b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the PIT.  <a href="#gaed902f6158d6681e4b05d078575e4b09">More...</a><br /></td></tr>
<tr class="separator:gaed902f6158d6681e4b05d078575e4b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eff20f412d72f94182b7fca0b3b0925"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga1eff20f412d72f94182b7fca0b3b0925">RTC_Init</a> (void(*userFunction)(void *), void *userArguments)</td></tr>
<tr class="memdesc:ga1eff20f412d72f94182b7fca0b3b0925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the RTC before first use.  <a href="#ga1eff20f412d72f94182b7fca0b3b0925">More...</a><br /></td></tr>
<tr class="separator:ga1eff20f412d72f94182b7fca0b3b0925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe916e4fad6bfc2ffcde604fa6afb52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gacbe916e4fad6bfc2ffcde604fa6afb52">RTC_Set</a> (const uint8_t hours, const uint8_t minutes, const uint8_t seconds)</td></tr>
<tr class="memdesc:gacbe916e4fad6bfc2ffcde604fa6afb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the real time clock.  <a href="#gacbe916e4fad6bfc2ffcde604fa6afb52">More...</a><br /></td></tr>
<tr class="separator:gacbe916e4fad6bfc2ffcde604fa6afb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e1f15e3b27e2de58d7f213a3bc865d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga46e1f15e3b27e2de58d7f213a3bc865d">RTC_Get</a> (uint8_t *const hours, uint8_t *const minutes, uint8_t *const seconds)</td></tr>
<tr class="memdesc:ga46e1f15e3b27e2de58d7f213a3bc865d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of the real time clock.  <a href="#ga46e1f15e3b27e2de58d7f213a3bc865d">More...</a><br /></td></tr>
<tr class="separator:ga46e1f15e3b27e2de58d7f213a3bc865d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5760d1a086ec79a33901db253000af9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gae5760d1a086ec79a33901db253000af9">UART_Init</a> (const uint32_t baudRate, const uint32_t moduleClk)</td></tr>
<tr class="memdesc:gae5760d1a086ec79a33901db253000af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the UART interface before first use.  <a href="#gae5760d1a086ec79a33901db253000af9">More...</a><br /></td></tr>
<tr class="separator:gae5760d1a086ec79a33901db253000af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03049bcc3bf9af2a75ee77016d3b0d60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga03049bcc3bf9af2a75ee77016d3b0d60">UART_InChar</a> (uint8_t *const dataPtr)</td></tr>
<tr class="memdesc:ga03049bcc3bf9af2a75ee77016d3b0d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a character from the receive FIFO if it is not empty.  <a href="#ga03049bcc3bf9af2a75ee77016d3b0d60">More...</a><br /></td></tr>
<tr class="separator:ga03049bcc3bf9af2a75ee77016d3b0d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20ebaeefd1f29d31e098ade31189dda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#gab20ebaeefd1f29d31e098ade31189dda">UART_OutChar</a> (const uint8_t data)</td></tr>
<tr class="memdesc:gab20ebaeefd1f29d31e098ade31189dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a byte in the transmit FIFO if it is not full.  <a href="#gab20ebaeefd1f29d31e098ade31189dda">More...</a><br /></td></tr>
<tr class="separator:gab20ebaeefd1f29d31e098ade31189dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799b375101827a18f652a3f28ecefcd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__module.html#ga799b375101827a18f652a3f28ecefcd0">UART_Poll</a> (void)</td></tr>
<tr class="memdesc:ga799b375101827a18f652a3f28ecefcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll the UART status register to try and receive and/or transmit one character.  <a href="#ga799b375101827a18f652a3f28ecefcd0">More...</a><br /></td></tr>
<tr class="separator:ga799b375101827a18f652a3f28ecefcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaabe3fea704d81e018d53b1ffec3d7f15"><td class="memItemLeft" align="right" valign="top"><a id="gaabe3fea704d81e018d53b1ffec3d7f15"></a>
volatile <a class="el" href="unionuint16union__t.html">uint16union_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>towerNumber</b> = NULL</td></tr>
<tr class="separator:gaabe3fea704d81e018d53b1ffec3d7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9be0a0a6e1cb0bf51763cde9ed47a17"><td class="memItemLeft" align="right" valign="top"><a id="gad9be0a0a6e1cb0bf51763cde9ed47a17"></a>
volatile <a class="el" href="unionuint16union__t.html">uint16union_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>towerMode</b> = NULL</td></tr>
<tr class="separator:gad9be0a0a6e1cb0bf51763cde9ed47a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74c1cf77ae5807a61baefd6df20201e"><td class="memItemLeft" align="right" valign="top"><a id="gac74c1cf77ae5807a61baefd6df20201e"></a>
<a class="el" href="union_t_packet.html">TPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Packet</b></td></tr>
<tr class="separator:gac74c1cf77ae5807a61baefd6df20201e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5faca24c448374dc4656ebc31afcae0b"><td class="memItemLeft" align="right" valign="top"><a id="ga5faca24c448374dc4656ebc31afcae0b"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>PACKET_ACK_MASK</b> = 0x80</td></tr>
<tr class="separator:ga5faca24c448374dc4656ebc31afcae0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section author"><dt>Author</dt><dd>Thanit Tangson &amp; Emile Fadel </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga445500277ba0e363873b34cffc015745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga445500277ba0e363873b34cffc015745">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(interrupt)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt service routine for the FTM. </p>
<p>Interrupt service routine for the UART.</p>
<p>Interrupt service routine for the RTC.</p>
<p>Interrupt service routine for the PIT.</p>
<p>If a timer channel was set up as output compare, then the user callback function will be called. </p><dl class="section note"><dt>Note</dt><dd>Assumes the FTM has been initialized. </dd></dl>

</div>
</div>
<a id="ga6407e3daf24a826a7f17d3e48865e89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6407e3daf24a826a7f17d3e48865e89a">&#9670;&nbsp;</a></span>FIFO_Get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FIFO_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_f_i_f_o.html">TFIFO</a> *const&#160;</td>
          <td class="paramname"><em>FIFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>dataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one character from the FIFO. </p>
<p>Gets data from the buffer. </p>

</div>
</div>
<a id="gad9207f49ab9ed061b6dca6063112ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9207f49ab9ed061b6dca6063112ca60">&#9670;&nbsp;</a></span>FIFO_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_f_i_f_o.html">TFIFO</a> *const&#160;</td>
          <td class="paramname"><em>FIFO</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the FIFO before first use. </p>
<p>Setting all parameters of the FIFO to 0 for initialization. </p>

</div>
</div>
<a id="gace64ba4e6bd943f990a294693156cc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace64ba4e6bd943f990a294693156cc3b">&#9670;&nbsp;</a></span>FIFO_Put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FIFO_Put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_f_i_f_o.html">TFIFO</a> *const&#160;</td>
          <td class="paramname"><em>FIFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put one character into the FIFO. </p>
<p>Checks if the Buffer has room and then puts data into the buffer, returning true. If the buffer is full it loops back around to the start of the buffer and returns false. </p>

</div>
</div>
<a id="ga50871aff0f5af1e092aea3ed2545cf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50871aff0f5af1e092aea3ed2545cf72">&#9670;&nbsp;</a></span>Flash_AllocateVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Flash_AllocateVar </td>
          <td>(</td>
          <td class="paramtype">volatile void **&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates space for a non-volatile variable in the Flash memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>is the address of a pointer to a variable that is to be allocated space in Flash memory. The pointer will be allocated to a relevant address: If the variable is a byte, then any address. If the variable is a half-word, then an even address. If the variable is a word, then an address divisible by 4. This allows the resulting variable to be used with the relevant Flash_Write function which assumes a certain memory address. e.g. a 16-bit variable will be on an even address </td></tr>
    <tr><td class="paramname">size</td><td>The size, in bytes, of the variable that is to be allocated space in the Flash memory. Valid values are 1, 2 and 4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the variable was allocated space in the Flash memory. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes Flash has been initialized. </dd></dl>

</div>
</div>
<a id="ga06868787ccef73e69bd236d3b93b68f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06868787ccef73e69bd236d3b93b68f3">&#9670;&nbsp;</a></span>Flash_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Flash_Erase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the entire Flash sector. </p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the Flash "data" sector was erased successfully. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes Flash has been initialized. </dd></dl>

</div>
</div>
<a id="gaa5782279b5e558cafc2f135c0a1177d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5782279b5e558cafc2f135c0a1177d3">&#9670;&nbsp;</a></span>Flash_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Flash_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Flash module. </p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the Flash was setup successfully. </dd></dl>

</div>
</div>
<a id="ga1458f5e4ac15e1848ae0bde32fe5b5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1458f5e4ac15e1848ae0bde32fe5b5f3">&#9670;&nbsp;</a></span>Flash_Write16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Flash_Write16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 16-bit number to Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the data. </td></tr>
    <tr><td class="paramname">data</td><td>The 16-bit data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if Flash was written successfully, FALSE if address is not aligned to a 2-byte boundary or if there is a programming error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes Flash has been initialized. </dd></dl>

</div>
</div>
<a id="ga5da7dcc0c6ef765546c79bbe25b48479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5da7dcc0c6ef765546c79bbe25b48479">&#9670;&nbsp;</a></span>Flash_Write32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Flash_Write32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 32-bit number to Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the data. </td></tr>
    <tr><td class="paramname">data</td><td>The 32-bit data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if Flash was written successfully, FALSE if address is not aligned to a 4-byte boundary or if there is a programming error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes Flash has been initialized. </dd></dl>

</div>
</div>
<a id="ga1e6f34b272d8ed7b0f897b43e65f2cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6f34b272d8ed7b0f897b43e65f2cc0">&#9670;&nbsp;</a></span>Flash_Write8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Flash_Write8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an 8-bit number to Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the data. </td></tr>
    <tr><td class="paramname">data</td><td>The 8-bit data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if Flash was written successfully, FALSE if there is a programming error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes Flash has been initialized. </dd></dl>

</div>
</div>
<a id="ga6a8e07494e5be81d37cc695feb380e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8e07494e5be81d37cc695feb380e68">&#9670;&nbsp;</a></span>FTM_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FTM_Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the FTM before first use. </p>
<p>Enables the FTM as a free running 16-bit counter. </p><dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the FTM was successfully initialized. </dd></dl>

</div>
</div>
<a id="gae4928af832114c8173e43d10e4144c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4928af832114c8173e43d10e4144c1f">&#9670;&nbsp;</a></span>FTM_Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FTM_Set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_f_t_m_channel.html">TFTMChannel</a> *const&#160;</td>
          <td class="paramname"><em>aFTMChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a timer channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFTMChannel</td><td>is a structure containing the parameters to be used in setting up the timer channel. channelNb is the channel number of the FTM to use. delayCount is the delay count (in module clock periods) for an output compare event. timerFunction is used to set the timer up as either an input capture or an output compare. ioType is a union that depends on the setting of the channel as input capture or output compare: outputAction is the action to take on a successful output compare. inputDetection is the type of input capture detection. userFunction is a pointer to a user callback function. userArguments is a pointer to the user arguments to use with the user callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the timer was set up successfully. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes the FTM has been initialized. </dd></dl>

</div>
</div>
<a id="gabb34a0dd79d879502fd81c0efa9440ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb34a0dd79d879502fd81c0efa9440ec">&#9670;&nbsp;</a></span>FTM_StartTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FTM_StartTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_f_t_m_channel.html">TFTMChannel</a> *const&#160;</td>
          <td class="paramname"><em>aFTMChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a timer if set up for output compare. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFTMChannel</td><td>is a structure containing the parameters to be used in setting up the timer channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the timer was started successfully. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes the FTM has been initialized. </dd></dl>

</div>
</div>
<a id="gac86820f24fb68dfbb9d2a3b772af94b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac86820f24fb68dfbb9d2a3b772af94b9">&#9670;&nbsp;</a></span>HandleNumberPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HandleNumberPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the tower number packet in accordance with the Tower Serial Communication Protocol document. </p>
<p>Parameter1 = 0x01, Parameter2 = LSB, Parameter3 = MSB If Parameter1 is 0x02, you are able to set LSB and MSB by passing these in through Parameter2 and Parameter3</p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the packet was handled successfully. </dd></dl>

</div>
</div>
<a id="gab7a5cb735555819b24719d6078028181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7a5cb735555819b24719d6078028181">&#9670;&nbsp;</a></span>HandlePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HandlePacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the packet by first checking to see what type of packet it is and processing it as per the Tower Serial Communication Protocol document. </p>
<p>Check if the handling of the packet was a success and an ACK packet was requested If that checks out, set the ACK bit to 1 Else, if the handling of the packet failed and an ACK packet was requested Clear the ACK bit in order to indicate a NAK (command could not be carried out) Finally, return the ACK packet to the Tower</p>

</div>
</div>
<a id="ga87fcb3feeebe2013c2376a2635080be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87fcb3feeebe2013c2376a2635080be5">&#9670;&nbsp;</a></span>HandleProgBytePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HandleProgBytePacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles a Flash Program Byte packet as per the Tower Serial Communication Protocol document by writing the data in parameter3 to the address given in parameter1. </p>
<p>Parameter1 = address offset (0-7), Parameter2 = 0, Parameter3 = data</p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the packet was handled successfully. </dd></dl>

</div>
</div>
<a id="ga229934574bc13961e301d7c8ea4742cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga229934574bc13961e301d7c8ea4742cc">&#9670;&nbsp;</a></span>HandleReadBytePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HandleReadBytePacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles a Flash Read Byte packet as per the Tower Serial Communication Protocol document by putting in a packet with the address of the flash byte read and the data contained in that address. </p>
<p>Parameter1 = address offset (0-7), Parameter2 = 0, Parameter3 = 0</p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the packet was handled successfully. </dd></dl>

</div>
</div>
<a id="ga5e7670b320e43d8d708a92bbe0746eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7670b320e43d8d708a92bbe0746eff">&#9670;&nbsp;</a></span>HandleSetTimePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HandleSetTimePacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles a Set Time packet as per the Tower Serial Communication Protocol document by setting sending the parameters of the packet to the RTC module to be set. </p>
<p>Parameter1 = hours(0-23), Parameter2 = minutes(0-59), Parameter3 = seconds (0-59)</p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the packet was handled successfully, FALSE if parameters out of range. </dd></dl>

</div>
</div>
<a id="gaa028adfe8bbcabdb7897a1898874e141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa028adfe8bbcabdb7897a1898874e141">&#9670;&nbsp;</a></span>HandleStartupPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HandleStartupPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The startup packet will send four packets back to the PC by default It will send the startup, version, tower number and mode packets. If flash is reset, tower number and mode will be set to studentNumber and defaultTowerMode. </p>
<p>Parameter1 = 0, Parameter2 = 0, Parameter3 = 0</p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if all of the packets were handled successfully. </dd></dl>

</div>
</div>
<a id="gae491978a09b1e90673364b69746bcae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae491978a09b1e90673364b69746bcae1">&#9670;&nbsp;</a></span>HandleTowerModePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HandleTowerModePacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the tower mode packet in accordance with the Tower Serial Communication Protocol document. </p>
<p>Parameter1 = 0x01, Parameter2 = LSB, Parameter3 = MSB If Parameter1 is 0x02, you are able to set LSB and MSB by passing these in through Parameter2 and Parameter3</p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the packet was handled successfully. </dd></dl>

</div>
</div>
<a id="ga84fe5ea768aedc0d1e4e2818ff8bd406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84fe5ea768aedc0d1e4e2818ff8bd406">&#9670;&nbsp;</a></span>HandleVersionPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HandleVersionPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the tower version packet in accordance with the Tower Serial Communication Protocol document. </p>
<p>Parameter1 = 'v', Parameter2 = 1, Parameter3 = 0 (V1.0) </p><dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the packet was handled successfully. </dd></dl>

</div>
</div>
<a id="gaea5d2a9d1aacacc05e4d772a555b2d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5d2a9d1aacacc05e4d772a555b2d9d">&#9670;&nbsp;</a></span>LEDs_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LEDs_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the LEDs before first use. </p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the LEDs were successfully initialized. </dd></dl>

</div>
</div>
<a id="gaefecb26a8d3457bc7f7a7b2fb8b7311f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefecb26a8d3457bc7f7a7b2fb8b7311f">&#9670;&nbsp;</a></span>LEDs_Off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LEDs_Off </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_l_e_ds_8h.html#a833ecccaa4c55e8365e84d6c02f92ec1">TLED</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns off an LED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>THe color of the LED to turn off. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that LEDs_Init has been called. </dd></dl>

</div>
</div>
<a id="ga1e5974ccd48f4e74eb3be78a51ebf16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e5974ccd48f4e74eb3be78a51ebf16f">&#9670;&nbsp;</a></span>LEDs_On()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LEDs_On </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_l_e_ds_8h.html#a833ecccaa4c55e8365e84d6c02f92ec1">TLED</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns an LED on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The color of the LED to turn on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that LEDs_Init has been called. </dd></dl>

</div>
</div>
<a id="ga00b9c778cd7168ea0df402b263a609bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b9c778cd7168ea0df402b263a609bb">&#9670;&nbsp;</a></span>LEDs_Toggle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LEDs_Toggle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_l_e_ds_8h.html#a833ecccaa4c55e8365e84d6c02f92ec1">TLED</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggles an LED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>THe color of the LED to toggle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that LEDs_Init has been called. </dd></dl>

</div>
</div>
<a id="gac58a17928cd5e556e1567b2fde9f88f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac58a17928cd5e556e1567b2fde9f88f0">&#9670;&nbsp;</a></span>Packet_Get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet_Get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get a packet from the received data. </p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if a valid packet was received. </dd></dl>

</div>
</div>
<a id="ga414aa3f521fdfd6e4586d98a946b6ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga414aa3f521fdfd6e4586d98a946b6ab2">&#9670;&nbsp;</a></span>Packet_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet_Init </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>moduleClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the packets by calling the initialization routines of the supporting software modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudRate</td><td>The desired baud rate in bits/sec. </td></tr>
    <tr><td class="paramname">moduleClk</td><td>The module clock rate in Hz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the packet module was successfully initialized. </dd></dl>

</div>
</div>
<a id="ga431a1e1da25a8214a502ec81f88fc3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga431a1e1da25a8214a502ec81f88fc3f1">&#9670;&nbsp;</a></span>Packet_Put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet_Put </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>parameter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>parameter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>parameter3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a packet and places it in the transmit FIFO buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if a valid packet was sent. </dd></dl>

</div>
</div>
<a id="gaed902f6158d6681e4b05d078575e4b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed902f6158d6681e4b05d078575e4b09">&#9670;&nbsp;</a></span>PIT_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PIT_Enable </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the PIT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>- TRUE if the PIT is to be enabled, FALSE if the PIT is to be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae69097a83912a25b357df1046aea9b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69097a83912a25b357df1046aea9b52">&#9670;&nbsp;</a></span>PIT_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PIT_Init </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>moduleClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>userFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userArguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the PIT before first use. </p>
<p>Enables the PIT and freezes the timer when debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleClk</td><td>The module clock rate in Hz. </td></tr>
    <tr><td class="paramname">userFunction</td><td>is a pointer to a user callback function. </td></tr>
    <tr><td class="paramname">userArguments</td><td>is a pointer to the user arguments to use with the user callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the PIT was successfully initialized. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that moduleClk has a period which can be expressed as an integral number of nanoseconds. </dd></dl>

</div>
</div>
<a id="gae012c6f6b7396828c558c92ad0a27ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae012c6f6b7396828c558c92ad0a27ed5">&#9670;&nbsp;</a></span>PIT_Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PIT_Set </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the desired period of the PIT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>The desired value of the timer period in nanoseconds. </td></tr>
    <tr><td class="paramname">restart</td><td>TRUE if the PIT is disabled, a new value set, and then enabled. FALSE if the PIT will use the new value after a trigger event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function will enable the timer and interrupts for the PIT. </dd></dl>

</div>
</div>
<a id="ga46e1f15e3b27e2de58d7f213a3bc865d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46e1f15e3b27e2de58d7f213a3bc865d">&#9670;&nbsp;</a></span>RTC_Get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC_Get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of the real time clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hours</td><td>The address of a variable to store the real time clock hours. </td></tr>
    <tr><td class="paramname">minutes</td><td>The address of a variable to store the real time clock minutes. </td></tr>
    <tr><td class="paramname">seconds</td><td>The address of a variable to store the real time clock seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that the RTC module has been initialized. </dd></dl>

</div>
</div>
<a id="ga1eff20f412d72f94182b7fca0b3b0925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eff20f412d72f94182b7fca0b3b0925">&#9670;&nbsp;</a></span>RTC_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC_Init </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>userFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userArguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the RTC before first use. </p>
<p>Sets up the control register for the RTC and locks it. Enables the RTC and sets an interrupt every second. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userFunction</td><td>is a pointer to a user callback function. </td></tr>
    <tr><td class="paramname">userArguments</td><td>is a pointer to the user arguments to use with the user callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the RTC was successfully initialized. </dd></dl>

</div>
</div>
<a id="gacbe916e4fad6bfc2ffcde604fa6afb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe916e4fad6bfc2ffcde604fa6afb52">&#9670;&nbsp;</a></span>RTC_Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC_Set </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the real time clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hours</td><td>The desired value of the real time clock hours (0-23). </td></tr>
    <tr><td class="paramname">minutes</td><td>The desired value of the real time clock minutes (0-59). </td></tr>
    <tr><td class="paramname">seconds</td><td>The desired value of the real time clock seconds (0-59). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that the RTC module has been initialized and all input parameters are in range. </dd></dl>

</div>
</div>
<a id="ga03049bcc3bf9af2a75ee77016d3b0d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03049bcc3bf9af2a75ee77016d3b0d60">&#9670;&nbsp;</a></span>UART_InChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UART_InChar </td>
          <td>(</td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>dataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a character from the receive FIFO if it is not empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataPtr</td><td>A pointer to memory to store the retrieved byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the receive FIFO returned a character. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that UART_Init has been called. </dd></dl>

</div>
</div>
<a id="gae5760d1a086ec79a33901db253000af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5760d1a086ec79a33901db253000af9">&#9670;&nbsp;</a></span>UART_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UART_Init </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>moduleClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the UART interface before first use. </p>
<p>Initializing the UART send parameters: baudRate = 115200, moduleClk = CPU_BUS_CLK_HZ (20,971,520 Hz) </p>

</div>
</div>
<a id="gab20ebaeefd1f29d31e098ade31189dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20ebaeefd1f29d31e098ade31189dda">&#9670;&nbsp;</a></span>UART_OutChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UART_OutChar </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a byte in the transmit FIFO if it is not full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The byte to be placed in the transmit FIFO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - TRUE if the data was placed in the transmit FIFO. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that UART_Init has been called. </dd></dl>

</div>
</div>
<a id="ga799b375101827a18f652a3f28ecefcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799b375101827a18f652a3f28ecefcd0">&#9670;&nbsp;</a></span>UART_Poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_Poll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll the UART status register to try and receive and/or transmit one character. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that UART_Init has been called. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
